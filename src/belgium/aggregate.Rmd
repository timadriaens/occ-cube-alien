---
title: "Aggregate occurrence data"
author:
- Damiano Oldoni
- Peter Desmet
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

In this document we aggregate data. The goal is to produce two *data cubes*, one at kingdom level (baseline for future corrections of research effort bias) and one at species level for taxa in the unfied checklist.

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r load_libraries}
library(tidyverse)      # To do datascience
library(sp)             # To work with geospatial data
library(here)           # To find files
library(rgbif)          # To use GBIF services
library(glue)           # To write queries
library(RSQLite)        # To interact with SQlite databases
```

Name and path of `.sqlite` file:

```{r name_path}
key <- "0044021-181108115102211"
sqlite_file <- paste(key, "occurrence.sqlite", sep = "_")
sqlite_path <- here("data", "interim", sqlite_file)
```

Table name:

```{r define_table_name}
table_name <- "occ_be"
```

Open connection to database:

```{r open_connection_to_db}
sqlite_occ <- dbConnect(SQLite(), dbname = sqlite_path)
```

# Aggregate at kingdom level - baseline

In this section we will calculate how many occurrences have been recorded for each year, EEA cell code and kingdom. For speeding up the search in database, we create an index on these rows if not present:

```{r create_idx_kingdom}
idx_baseline <- "idx_year_cell_kingdom"
# get indexes on table
query <- glue_sql(
    "PRAGMA index_list({table_name})",
    table_name = table_name,
    .con = sqlite_occ
)
indexes_all <- dbGetQuery(sqlite_occ, query)

# create index if not present
if (!idx_baseline %in% indexes_all$name) {
  query <- glue_sql(
  "CREATE INDEX {`idx`} ON {table_name} ({`cols_idx`*})",
  idx = idx_baseline,
  table_name = table_name,
  cols_idx = c("year", 
               "eea_cell_code", 
               "kingdomKey", 
               "coordinateUncertaintyInMeters"),
  .con = sqlite_occ
  )
  dbExecute(sqlite_occ, query)
}
```

Group by  `year`, `eea_cell_code` and `kingdomKey` and count number of occurrences for each group. We also add the lowest value of coordinate uncertainty.

```{r get_datacube_kingdom}
query <- glue_sql(
  "SELECT {`cols`*}, COUNT(_ROWID_), MIN({`coord_uncertainty`}) FROM {table} GROUP BY {`cols`*}",
  cols = c("year", "eea_cell_code", "kingdomKey"),
  coord_uncertainty = "coordinateUncertaintyInMeters",
  table = table_name,
  .con = sqlite_occ
)
occ_cube_baseline <- 
  dbGetQuery(sqlite_occ, query) %>%
  rename(
    n = "COUNT(_ROWID_)",
    min_coord_uncertainty = "MIN(`coordinateUncertaintyInMeters`)"
)
```

Preview:

```{r preview_occ_cube_baseline}
occ_cube_baseline %>% 
  head()
```

The kingdom names can be retrieved easily by GBIF:

```{r get_kingdom}
kingdom_df <- tibble(
  kingdomKey = unique(occ_cube_baseline$kingdomKey))
kingdom_df <- 
  kingdom_df %>%
  mutate(kingdom = map_chr(
    kingdomKey, 
    function(x) {
      name_usage(x, return = "data") %>%
        pull(scientificName)
      })
  )
kingdom_df
```

Save as tab separated text file:

```{r save_baseline_datacube}
write_tsv(occ_cube_baseline,
          here("data", "processed", "cube_belgium_baseline.tsv"),
          na = "")
```

# Aggregate at species level - baseline

## Select occurrences related to alien species

We extract taxa from unified checklist:

```{r get_alien_species}
datasetKey <- "6d9e952f-948c-4483-9807-575348147c7e"
alien_taxa <- name_usage(
  datasetKey = datasetKey, 
  return = "data",
  limit = 10000)  %>%
  filter(origin == "SOURCE")
```

Rank present values in checklist:

```{r overview_rank}
alien_taxa %>%
  group_by(rank) %>%
  count()
```

Taxonomic status values present in checklist:

```{r taxonStatus}
alien_taxa %>%
  group_by(taxonomicStatus) %>%
  count()
```

## Select occurrences of accepted species

As initial step, we start by selecting occurrences linked to taxa with rank `SPECIES` and taxonomic status `ACCEPTED` and `DOUBTFUL`:

```{r alien_taxa_species}
alien_taxa_species <- 
  alien_taxa %>%
  filter(rank == "SPECIES", 
         taxonomicStatus %in% c("ACCEPTED", "DOUBTFUL"))
alien_taxa_species %>% head()
```

The `nubKey` of these taxa are the `speciesKey` we can filter on:

```{r get_alien_taxa_species_key}
alien_taxa_species_key <-
  alien_taxa_species %>% 
  distinct(nubKey) %>% 
  pull(nubKey)
```

For speeding up the aggregation, we create an index on  `year`,  `eea_cell_code` and `speciesKey` if not present:

```{r create_idx_speciesKey}
idx_species_year_cell <- "idx_species_year_cell"
# get indexes on table
query <- glue_sql(
    "PRAGMA index_list({table_name})",
    table_name = table_name,
    .con = sqlite_occ
)
indexes_all <- dbGetQuery(sqlite_occ, query)

# create index if not present
if (!idx_species_year_cell %in% indexes_all$name) {
  query <- glue_sql(
  "CREATE INDEX {`idx`} ON {table_name} ({`cols_idx`*})",
  idx = idx_species_year_cell,
  table_name = table_name,
  cols_idx = c("year", 
               "eea_cell_code", 
               "speciesKey",
               "coordinateUncertaintyInMeters"),
  .con = sqlite_occ
  )
  dbExecute(sqlite_occ, query)
}
```

Group by `year`, `eea_cell_code` and `speciesKey`, count number of occurrences for each group and get the lowest value of coordinate uncertainty `occurrenceUncertaintyInMeters`:

```{r get_datacube_species}
query <- glue_sql(
  "SELECT {`cols`*}, COUNT(_ROWID_), MIN({`coord_uncertainty`}) FROM {table} GROUP BY {`cols`*}",
  cols = c("year", 
           "eea_cell_code", 
           "speciesKey", 
           "coordinateUncertaintyInMeters"),
  coord_uncertainty = "coordinateUncertaintyInMeters",
  table = table_name,
  .con = sqlite_occ
)
occ_cube_species <- 
  dbGetQuery(sqlite_occ, query) %>%
  rename(
    n = "COUNT(_ROWID_)",
    min_coord_uncertainty = "MIN(`coordinateUncertaintyInMeters`)"
)
occ_cube_species <-
  occ_cube_species %>%
  mutate(speciesKey = as.integer(speciesKey)) %>%
  filter(speciesKey %in% alien_taxa_species_key) %>%
```

Number of alien species included in occurrence cube:

```{r species_included}
length(alien_taxa_species_key[
  which(alien_taxa_species_key %in% unique(occ_cube_species$speciesKey))
])
```

Number of alien species not included in occurrence cube:

```{r species_not_included}
length(alien_taxa_species_key[
  which(!alien_taxa_species_key %in% unique(occ_cube_species$speciesKey))
])
```

Preview:

```{r preview_occ_species}
occ_cube_species %>% head()
```

## Select occurrences related to taxa below species rank

Accepted taxa in unified cheklist with rank below species:

```{r alien_taxa_under_species}
rank_under_species <- c("SUBSPECIFICAGGREGATE",
                        "SUBSPECIES", 
                        "VARIETY",
                        "SUBVARIETY",
                        "FORM",
                        "SUBFORM"
)
alien_taxa_subspecies <-
  alien_taxa %>%
  filter(rank %in% rank_under_species, 
         taxonomicStatus %in% c("ACCEPTED", "DOUBTFUL"))
alien_taxa_subspecies
```

For these taxa we will search by keys from field `nubKey`, the taxon keys of taxa from the GBIF taxonomy backbone:

```{r get_alien_taxa_subspecies}
alien_taxa_subspecies_key <-
  alien_taxa_subspecies %>% 
  distinct(nubKey) %>% 
  pull(nubKey)
```

Get occurrences related to these taxa and their synonyms by filtering on `acceptedTaxonKey`, group by `year`, `eea_cell_code` and `acceptedTaxonKey`, count number of occurrences and get the lowest value of coordinate uncertainty `occurrenceUncertaintyInMeters`: 

```{r get_occurrences_subspecies}
query <- glue_sql(
  "SELECT {`cols`*} FROM {table} WHERE acceptedTaxonKey IN ({subspecies_key*})",
  cols = c("year", 
           "eea_cell_code", 
           "speciesKey", 
           "acceptedTaxonKey",
           "coordinateUncertaintyInMeters"),
  subspecies_key = alien_taxa_subspecies_key,
  table = table_name,
  .con = sqlite_occ
)
occ_cube_subspecies <- 
  dbGetQuery(sqlite_occ, query) %>%
  rename(taxonKey = acceptedTaxonKey) %>%
  group_by(year, eea_cell_code, speciesKey, taxonKey) %>%
  summarize(
    n = n(),
    min_coord_uncertainty = min(coordinateUncertaintyInMeters)
)
```

Number of taxa below species rank included in `occ_cube_subspecies`:

```{r subspecies_included}
length(alien_taxa_subspecies_key[
  which(alien_taxa_subspecies_key %in% 
          unique(occ_cube_subspecies$taxonKey))])
```

Number of taxa below species rank not included in `occ_cube_subspecies`:

```{r subspecies_not_included}
length(alien_taxa_subspecies_key[
  which(!alien_taxa_subspecies_key %in% 
          unique(occ_cube_subspecies$taxonKey))])
```

Preview:

```{r preview_occ_cube_subspecies}
occ_cube_subspecies %>% head()
```

## Select occurrences related to synonyms

Some taxa in unified checklists are synonyms. For these taxa we don't trust the link to accepted taxa provided by GBIF.

Get synonyms from unified checklist:

```{r alien_taxa_synonyms}
alien_taxa_synonyms <-
  alien_taxa %>%
  filter(!taxonomicStatus %in% c("ACCEPTED", "DOUBTFUL"))
alien_taxa_synonyms
```

Rank distribution:

```{r rank_synonym}
alien_taxa_synonyms %>%
  group_by(rank) %>%
  count() %>%
  arrange(desc(n))
```

For these taxa we will search by keys from field `nubKey`:

```{r get_alien_taxa_synonyms_key}
alien_taxa_synonyms_key <-
  alien_taxa_synonyms %>% 
  distinct(nubKey) %>% 
  pull(nubKey)
```

Get occurrences, group by `year`, `eea_cell_code` and `taxonKey`, count number of occurrences and get the lowest value of coordinate uncertainty `occurrenceUncertaintyInMeters`: 

```{r get_occurrences_synonyms}
query <- glue_sql(
  "SELECT {`cols`*} FROM {table} WHERE taxonKey IN ({synonym_key*})",
  cols = c("year", 
           "eea_cell_code", 
           "taxonKey",
           "coordinateUncertaintyInMeters"),
  synonym_key = alien_taxa_synonyms_key,
  table = table_name,
  .con = sqlite_occ
)
occ_cube_synonym <- 
  dbGetQuery(sqlite_occ, query) %>%
  group_by(year, eea_cell_code, taxonKey) %>%
  summarize(
    n = n(),
    min_coord_uncertainty = min(coordinateUncertaintyInMeters)
)
```

Number of synonyms included in `occ_cube_synonym`:

```{r synonyms_included}
length(alien_taxa_synonyms_key[
  which(alien_taxa_synonyms_key %in% 
          unique(occ_cube_synonym$taxonKey))])
```

Number of synonyms not included in `occ_cube_synonym`:

```{r synonyms_not_included}
length(alien_taxa_synonyms_key[
  which(!alien_taxa_synonyms_key %in% 
          unique(occ_cube_synonym$taxonKey))])
```

Preview:

```{r preview_occ_cube_subspecies}
occ_cube_synonym %>% head()
```

# Save occurrence cube for Belgium

In previous section we created three cubes by counting number of species per:

1. accepted species, `occ_cube_species`
2. accepted taxa below species level, `occ_cube_subspecies`
3. synonyms, `occ_cube_synonym`

Overview:

```{r overview_occ_cube_species}
head(occ_cube_species)
```

```{r overview_occ_cube_subspecies}
head(occ_cube_subspecies)
```

```{r overview_occ_cube_synonym}
head(occ_cube_synonym)
```

Save as tab separated text file:

```{r save_baseline_datacube}
write_tsv(, 
          here("data", "processed", "cube_belgium.tsv"),
          na = ""
)
```

Close connection:

```{r close_connection}
dbDisconnect(sqlite_occ)
```
